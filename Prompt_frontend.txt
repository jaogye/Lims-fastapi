# 
# This file contains the prompts used in the creation of this app. The code generator is Claude Code. 
#
====================================================================================================
This python app is migration from a matlab app. So far we have implemented the backend of the python app.

Now I want to create a web frontend for the python app. 

Let me to explain the frontend of this app when was implemented
in matlab. In the folder images there are print screens of this matlab webapp.
The main form of this matlab app is a multi-form canvas in which the user can switch into several forms.
I used the multi-form in matlab since Matlab webapp do not have a mechanism to show popup windows to show messages.
Hence to show messages in Matlab webapp I create a console form in this multi-form to show messages. 
Now I am going to explain you the frontend of the matlab app and what functionality in terms of the endpoints of the new python app. 
  
1) images\main.png shows a canvas for user validation. 

If the user is  new then the user needs to enter a new password. 
Then the hidden visual elements are visible and the user can type the new password once done this the visual elements are hidden again. 

In new frontend the buttons:
a) Click on button 'Sign In' the app runs the endpoint @router.post("/login", response_model=TokenResponse)

b) Click on button 'Sign out' the app runs the endpoint @router.post("/logout")


2) image\MasterTable.png shows a form that contains: a grid table, a dropdown list containing the table-type names : "products", "qualities", "variables", "holidays", "sample_points", "spec-client", "spec-gen", "samplematrix", "maps" ] and two buttons 'Download' and 'Upload'.

The user must select a table-type name from the list. If the user clicks on 'Download', the app runs the endpoint @router.get("/download/{table_type}") and the result of this endpoint is shown in the grid table and shows a popup window to select the folder and the file name excel where the result of these will be stored. 

If the user clicks on 'Upload' then the app shows a popup window so that the user selects which excel file from the local file systems. Once selected the app runs the endpoint @router.post("/upload"). Then the loaded table is shown in the grid table and if this endpoints raise errors shows these to user. 
 

3) images\InputData.png shows a form that to input the results of samples in a lab for a given day. 

The user inputs a date and then click on 'Get Data' which runs the endpoints 
first @router.post("/create-sample") and 
second @router.get("/get_samples", response_model=List[SampleDetailResponse]).
Sample numbers of the result of this endpoints are filled in the sample list as you can see in the form images\viewlabo.jpg. In this form the sample numbers 
have a color. If all measurements of a sample number are inputted  then sample number is completed then the sample number in the list must have green color otherwise must have an orage color. If the user click on any sample number, then the list of item-value are filled with values of the sample and the list of quality info is filled with the quality_info field. Then the user can input the measurement's value of each value of this sample. Hence the user can input the measurement's values of any sample.

If the attributes sample.coa is 'Y' then the button 'COA' appears (it is visible). If the user clicks on button 'COA', the app runs the endpoint @router.get("/coa/{sample_number}") with the sample number of the current user's selection. 

If the attributes sample.coc is 'Y' then the button 'COC' appears (it is visible). If the user clicks on button 'COC', the app runs the endpoint @router.get("/coc/{sample_number}") with the sample number of the current user's selection.

If the attributes sample.day_coa is 'Y' then the button 'C of day' appears (it is visible). If the user clicks on button 'C of day', the app runs the endpoint @router.get("/day-certificate/{sample_number}") with the sample number of the current user's selection.

When the user clicks on button 'Update', the app runs the endpoints @router.post("/update_samples") if this endpoint raises errors, these errors must be shown to the user.   


4) images\manualsample.png shows a form to input an order to do manual sample. We don't have endpoints for this form. So create the necessary endpoints for this form.

5) images\useradministration.png shows a form to create a new user and define the access that the new user has access and load the image file with the signature of the new user.

Now write a model and functional web frontend based on javascript and typescript for the python app. You can create new endpoints if there are necessary to accomplish this task. 
Additional if you need further information from me you can ask me. 



======================================================================================================


1) Create a get endpoint called get_samples that receives as parameter sample_date a string date in the format "YYYY-MM-DD" and gets a json string  


[{"sample_number": str,  "customer_name": str, 
  "product": str, "quality":str, "tank":str, 
  "sample_date":str, "orderPVS":str, "orderclient": str,
  "batch_number":str, "container_number":str, "remark":str,
  "quality_info": [
    {"variable": str, "min": float,
    "max":float, "value": float },
   ]
  },
]
The elements of this list are  samples corresponding to client and Manual sample (type_sample='CLI' or type_sample='MAN') stored in the table sample and corresponding to sample of the same sample date (sample.date = sample_date). This fields of each sample except "quality_info" are in the tables sample, product, quality and samplepoint. The string names   
"product": str, "quality":str, "tank":str correspond to product.name, quality name and samplepoint.name. The field "quality_info" is list of measurements corresponding to each sample and those measurements are stored in the table measurement.

 

2) Create a post endpoint called update_samples that receives a list of updated samples. This a json string with following format:

[{"sample_number": str,  "customer_name": str, 
  "product": str, "quality":str, "tank":str, 
  "sample_date":str, "orderPVS":str, "orderclient": str,
  "batch_number":str, "container_number":str, "remark":str,
  "quality_info": [
    {"variable": str, "min": float,
    "max":float, "value": float },
   ]
  },
]
Each element of the list is a sample. The fields of each sample that are not "quality_info" must be updated into the table sample using the key sample_number. The fields "product", "quality" and "tank" are string names but their values in the table sample are product_id, quality_id and samplepoint_id. The numerical values are obtained using the string names as keys from the tables product, quality and samplepoint. The field "quality_info" contains a list of measurements done for each variable of the sample. These values will be stored in the table measurement using the key sample_id (this value is obtained from sample table using sample_number as key ) and variable_id (this value is obtained from variable table using variable string name as key). 
 
Previously to the update, the endpoint must validate if each value of the measurement agrees with range of allowed values defined by  min and max fields for each measurement. If a value is out of range, the endpoint must raise an error showing which measurement is not correct.  

 

1) Modify the endpoint @router.get("/get_samples", response_model=List[SampleDetailResponse]) so that each sample of the output list 
has the following additional fields from the table sample: sample.product_id, sample.quality_id, sample.samplepoint_id, sample.certificate, sample.coa, sample.coc and sample.day_coa

2) Modify the endpoint @router.post("/update_samples") to receives a json string in the following format:
[{"sample_number": str,  "customer_name": str, 
  "product": str, "quality":str, "tank":str, 
  "sample_date":str, "orderPVS":str, "orderclient": str,
  "batch_number":str, "container_number":str, "remark":str,
  "sample_product_id": int, "sample_quality_id": int, "sample_samplepoint_id", "sample_certificate":str, "sample_coa": str, "sample.coc": str, "sample_day_coa":str,
  "quality_info": [
    {"variable": str, "min": float,
    "max":float, "value": float },
   ]
  },
]
Modify this endpoint to update the value of the following fields in each sample: "tank", "container_number", "batch_number" and "remark".


Modify the endpoint @router.post("/update_samples") to validate of the field "tank" for each sample. This validation is based on the table samplepoint. "tank" must appear
as a name of a samplepoint. The endpoint must store value of "tank" in the column sample.samplepoint_name. 



This is piece of code in the class SampleService:

            # Validate field lengths to prevent database truncation errors
            if sample_data.get("tank") and len(sample_data["tank"]) > 40:
                validation_errors.append(
                    f"Sample {sample_number}: tank name exceeds maximum length of 40 characters (current: {len(sample_data['tank'])})"
                )

            if sample_data.get("container_number") and len(sample_data["container_number"]) > 20:
                validation_errors.append(
                    f"Sample {sample_number}: container_number exceeds maximum length of 20 characters (current: {len(sample_data['container_number'])})"
                )

            if sample_data.get("batch_number") and len(sample_data["batch_number"]) > 20:
                validation_errors.append(
                    f"Sample {sample_number}: batch_number exceeds maximum length of 20 characters (current: {len(sample_data['batch_number'])})"
                )

            if sample_data.get("remark") and len(sample_data["remark"]) > 100:
                validation_errors.append(
                    f"Sample {sample_number}: remark exceeds maximum length of 100 characters (current: {len(sample_data['remark'])})"
                )


Modify this code such that the maximum values of the length of fields are obtained from the column definition of the data model of sample.




===================================================================================================

I have modified the endpoint @router.post("/upload") to add the field  "pendingdata" in its response body. This field contains a json string from a pandas dataframe. 
This endpoint is used in the option "Master Table" of the frontend of this app. 

images\console.png shows a form to show the error messages generated by the endpoint @router.post("/upload"). This form has two textfields : 'Error Message'   
and 'Pending Data'. The textfield 'Error Message' show the field "errors" of the response body of the endpoint and the textfield 'Pending Data' shows in format table the field
"pendingdata" of the response body of the endpoint.  

The form also has two buttons 'Download Messages' and 'Download Pendings'. The button 'Download Messages' generates a text file from the contents of the textfield 'Error Message' 
and asks to the user where the text file will be saved. The button 'Download Pending' generates an excel file from the contents of the textfield 'Pending Data' and asks to the user where the excel file will be saved.  

This forms is shown to the user only when the endpoint generates an error, that means the field "pendingdata" is not null. 

Modify the frontend of this app to add the functionaly of this form. If you need to ask further questions, you can ask me. 

======================================================================================================

The table column sample.spec_id is not null and the menu option 'Manual Sample' insert a row of the table sample with a null value for sample.spec_id. 
The value of sample.spec_id is obtained from the query: SELECT id FROM spec where type_spec='GEN' and product_id=:nproduct and quality_id=:nquality , where 
the parameters :nproduct and :nquality are obtained from the user's selection for the dropdown lists : product and quality from the form 'Manual Sample'.

Modify the frontend of the form 'Manual Sample' such that the value for sample.spec_id is properly filled. To get the a proper value for sample.spec_id from the user,
the droplistbox product of the form must show all the products from the table product and once a product's name is selected from the user the droplistbox quality is filled using the 
following query select q.name from quality q, spec s where s.type_spec='GEN' and s.quality_id =q.id and and s.product_id=:nproduct , where :nproduct is the id of the product selected 
by the user. 

Modify this app such that the form 'Manual Sample' satisfies to the new requeriments.  
If you have further questions about this task, you can ask me.   

=======================================================================================================

The visual element 'Sample Time *' of the form 'Manual Sample' does not show the time of the sample once the user clicks on the button 'Edit' to modify a row selected from the table grid. 
Correct this problem.
  
===========================================================================================================

Implement the option 'Input data' of the frontend. Recall the requirements for 'Input Data' are :

images\InputData.png shows a form that to input the results of samples in a lab for a given day. 

The user inputs a date and then click on 'Get Data' which runs the endpoints 
first @router.post("/create-sample") and 
second @router.get("/get_samples", response_model=List[SampleDetailResponse]).
Sample numbers of the result of this endpoints are filled in the sample list as you can see in the form images\viewlabo.jpg. In this form the sample numbers 
have a color. If all measurements of a sample number are inputted  then sample number is completed then the sample number in the list must have green color otherwise must have an orage color. If the user click on any sample number, then the list of item-value are filled with values of the sample and the list of quality info is filled with the quality_info field. Then the user can input the measurement's value of each value of this sample. Hence the user can input the measurement's values of any sample.

If the attributes sample.coa is 'Y' then the button 'COA' appears (it is visible). If the user clicks on button 'COA', the app runs the endpoint @router.get("/coa/{sample_number}") with the sample number of the current user's selection. 

If the attributes sample.coc is 'Y' then the button 'COC' appears (it is visible). If the user clicks on button 'COC', the app runs the endpoint @router.get("/coc/{sample_number}") with the sample number of the current user's selection.

If the attributes sample.day_coa is 'Y' then the button 'C of day' appears (it is visible). If the user clicks on button 'C of day', the app runs the endpoint @router.get("/day-certificate/{sample_number}") with the sample number of the current user's selection.

When the user clicks on button 'Update', the app runs the endpoints @router.post("/update_samples") if this endpoint raises errors, these errors must be shown to the user.   

Additionally the body response of the endpoint @router.post("/create-sample") has two fields : "customer_result" and "production_result" and these fields have the fields :
"errors" and "pendingdata" for the field "customer_result". The fields of "errors" are not empty then errors messages must be shown in the console error form similar to the form 'Master Table' and also showing   "pendingdata".  

If you have further questions about this task, you can ask me.

=============================================================================================================

Modify the option 'Input data' of the frontend so that the user can edit the following fields: container, tank, batch and remark.

The fields container, batch, and remark are strings that are edited using textfields. 

The field tank is edited using dropdownlist that is loaded using the following query:

SELECT distinct sp.name FROM samplepoint sp, samplematrix sm WHERE  sm.samplepoint_id=sp.id and sm.product_id=:nproduct and sm.quality_id=:nquality ORDER BY sp.name
, where :nproduct and :nquality are parameters that are the values of sample.product_id and sample.quality_id 

Modify this app such that the form 'Input data' satisfies to the new requeriments.  
If you have further questions about this task, you can ask me.   

=============================================================================================================


This app has a problem. Everytime that I close the browser without 'Sign out' this app and then I load this app again in another browser session, the app shows me the menu options
without 'Sign in' but this session is failed since the app is properly initiated. Modify this app such that everytime that I close the browser without 'Sign out' the app must do a 'Sign out'. 

============================================================================================================

Implements the menu option 'User Admin' of this app. This menu option should look like as in images\useradministration.png that shows a form to create a new user and define the access that the new user has access and load the image file with the signature of the new user. This form uses the tables : tuser, optionmenu and optionuser. This form must store a png file that contains user's signature
 
If you have further questions about this task, you can ask me.

============================================================================================================

I have added two columns into the table tuser:

email NVARCHAR(320)
and
temp_password bit 

I have to do the following modifications in the menu option 'User Admin'.


1) Add a textfield to input the user's email. 
2) Add a check box 'Reset Password'. If the user of this option clicks on this check box, the app must clear the user's password and generate a secret password that will be saved into the table tuser as a hashcode and sent this password to the user by an email. And the app must save a True value in the column tuser.temp_password. This true value says that app must show a form to the user that allow to her to change her password. This form must appears every time that she enters to app until she change her password. Once that she changed the password the form to change passwords must be omitted.  

3) When the user load a new signature file, this image of the signature must be keep in the form after the update and also the image of this signature must be shown every time that 
 the user of this menu option wants to edit a user's data.  

If you have further questions about this task, you can ask me.

============================================================================================================

I have to make the following modifications in the app.

Every form (menu option) must appear the user code. Every time that a user logins into the app, the app must only show the options that this user can access.

If you have further questions about this task, you can ask me.
 
============================================================================================================

When a user click on a menu option that does not have access, disable all buttons of this form. 
I do not see the user code in app when I user login.
 

============================================================================================================

Eliminate in the menu option 'User Admin' the textfield to input password. Now user's password is created first as temporary password and sent to the user by an email and then the user will create a new password when she enter to the app.

============================================================================================================

First I modify the table optionMenu such that now the names of the menu option are identical to the menu options implemented in the app.

optionMenu
id      name
1	Master Tables                 
2	Input Data                    
3	Manual Sample                 
4	Report Gen                    
5	View Jobs                     
6	User Admin                    

Implement the menu option 'Report Gen' of the frontend. 

images\reportgeneration.png shows the image of a form that implements this menu option. There is a textfield to select a date and with the button 'Select' the app selects the samples stored from the table sample by showing the samplenumber, product, quality and samplepoint (tank). Then the user click on a row of selected samples and shows their values of this row (sample) in the   textfields besides and then the buttons 'COA', 'COC' and 'C of Day' are enabled according if the values of the columns sample.coa, sample.coc or sample.day_coa is equal to 'X'. 

When the user clicks on the buttons 'COA', 'COC' and 'C of Day' prints the corresponding report identical behaviour in the menu option 'Input Data'. 


Implement the menu option 'View Jobs' of the frontend. 

images\viewjobs shows the image of a form that implements this menu option.  There is a textfield to select a date and with the button 'Select' the app selects the non-complete samples stored from the table sample by showing the samplenumber, product, quality and samplepoint (tank). There are textfields showing the total number of samples, total number of non-complete samples.  

When the user click on a row (a sample) of selected samples and the app shows the pending tests (variables) of this sample. 
   
  
If you have further questions about this task, you can ask me.
============================================================================================================

Update the file readme.md accoring the current state of the app.

============================================================================================================


